{"version":3,"file":"repeatClean.js","sourceRoot":"","sources":["../src/directives/repeatClean.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {directive, Directive, NodePart, removeNodes, reparentNodes, TemplateFactory} from '../lit-html.js';\nimport { TemplateResult } from '../lib/shady-render.js';\n\nexport type KeyFn<T> = (item: T) => any;\nexport type ItemTemplate<T> = (item: T, index: number) => any;\n\nclass KeyedNodePart extends NodePart {\n  key: any;\n  pooledNodes: DocumentFragment | null = null;\n  constructor(templateFactory: TemplateFactory, key: any ) {\n    super(templateFactory);\n    this.key = key;\n  }\n}\n\ninterface KeyedTemplateResult extends TemplateResult {\n  key: any;\n}\n\ntype PartPool = Map<any, KeyedNodePart>;\n\ninterface RepeatOptions {\n  lis?: boolean,\n  pool?: PartPool,\n  reuse: boolean\n}\n\nfunction createPart(parentPart: NodePart, result: KeyedTemplateResult,\n  beforePart?: NodePart | null | undefined,\n  pool?: PartPool, reuse?: boolean): KeyedNodePart {\n  const container = parentPart.startNode.parentNode as Node;\n  const beforeNode = beforePart ? beforePart.startNode : parentPart.endNode;\n  let newPart;\n  if (pool) {\n    newPart = pool.get(result.key);\n    if (!newPart && reuse && pool.size > 0) {\n      newPart = pool.values().next().value;\n    }\n    if (newPart) {\n      pool.delete(newPart.key);\n      if (newPart.pooledNodes) {\n        container.insertBefore(newPart.pooledNodes, beforeNode);\n      } else {\n        movePart(parentPart, newPart, beforePart);\n      }\n      newPart.key = result.key;\n    }\n  }\n  if (!newPart) {\n    const startNode = document.createComment('');\n    const endNode = document.createComment('');\n    container.insertBefore(startNode, beforeNode);\n    container.insertBefore(endNode, beforeNode);\n    newPart = new KeyedNodePart(parentPart.templateFactory, result.key);\n    newPart.insertAfterNode(startNode);\n  }\n  updatePart(newPart, result);\n  return newPart;\n}\n\nfunction updatePart(part: KeyedNodePart, result: TemplateResult) {\n  part.setValue(result);\n  part.commit();\n  return part;\n}\n\nfunction movePart(parentPart: NodePart, partToMove: NodePart, beforePart: NodePart | null | undefined) {\n  const container = parentPart.startNode.parentNode as Node;\n  const beforeNode = beforePart ? beforePart.startNode : parentPart.endNode;\n  const endNode = partToMove.endNode.nextSibling;\n  if (endNode !== beforeNode) {\n    reparentNodes(container, partToMove.startNode, endNode, beforeNode);\n  }\n}\n\nfunction removeOrPoolPart(part: KeyedNodePart, pool?: PartPool) {\n  if (pool) {\n    pool.set(part.key, part);\n  } else {\n    removeNodes(part.startNode.parentNode as Node, part.startNode, part.endNode.nextSibling);\n  }\n}\n\nfunction poolPartNodes(part: KeyedNodePart) {\n  if (part.startNode.parentNode !== null) {\n    let nodes = part.pooledNodes;\n    if (!nodes) {\n      nodes = part.pooledNodes = document.createDocumentFragment();\n    }\n    let start = part.startNode;\n    let end = part.endNode.nextSibling;\n    for (let n:Node|null=start; n && n!=end;) {\n      const next: Node|null = n.nextSibling;\n      nodes.appendChild(n);\n      n = next;\n    }\n  }\n}\n\nfunction createKeyToIndexMap(items: Array<KeyedNodePart|KeyedTemplateResult|null>, start: number, end: number) {\n  const map = new Map<any, number>();\n  for (let i=start; i<=end; i++) {\n    const item = items[i];\n    if (item !== null) {\n      map.set(item.key, i);\n    }\n  }\n  return map;\n}\n\nfunction removeUnusedOldParts(\n  oldParts: Array<KeyedNodePart|null>, oldPartKeyToIndexMap: Map<any, number>,\n  newResults: Array<KeyedTemplateResult>, newStartIndex: number, newEndIndex: number,\n  pool?: PartPool) {\n  let removed = 0;\n  const newResultKeyToIndexMap = createKeyToIndexMap(newResults, newStartIndex, newEndIndex);\n  for (let [key, oldPartIdx] of oldPartKeyToIndexMap) {\n    if (!newResultKeyToIndexMap.has(key)) {\n      // parts in this range are guaranteed to be non-null\n      const oldPart = oldParts[oldPartIdx] as KeyedNodePart;\n      removeOrPoolPart(oldPart, pool);\n      oldParts[oldPartIdx] = null;\n      removed++;\n    }\n  }\n  return Boolean(removed);\n}\n\nfunction createOldIndexLIS(\n  oldPartKeyToIndexMap: Map<any, number>, newResults: Array<KeyedTemplateResult>,\n  newStartIndex: number, newEndIndex: number): Set<number> {\n  let newIndexToOldIndex: Array<number> = [];\n  for (let i=newStartIndex; i<=newEndIndex; i++) {\n    newIndexToOldIndex[i] = oldPartKeyToIndexMap.get(newResults[i].key) || -1;\n  }\n  let tails = [newStartIndex];\n  let prev = [-1];\n  for (let i=newStartIndex+1; i<=newEndIndex; i++) {\n    const val = newIndexToOldIndex[i];\n    if (val < 0) {\n      continue;\n    }\n    let max = tails[tails.length-1];\n    if (val > newIndexToOldIndex[max]) {\n      prev[i] = max;\n      tails.push(i);\n    } else {\n      let start = 0, end = tails.length-1;\n      while (start < end) {\n        const mid = start + end >> 1;\n        const midVal = newIndexToOldIndex[tails[mid]];\n        if (midVal < val) {\n          start = mid + 1;\n        } else if (midVal > val) {\n          end = mid;\n        } else {\n          start = mid;\n          break;\n        }\n      }\n      prev[i] = tails[start-1];\n      tails[start] = i;\n    }\n  }\n  const lis = new Set();\n  for (let i=tails.length-1, j=tails[tails.length-1]; i>=0; i--, j=prev[j]) {\n    lis.add(newIndexToOldIndex[j]);\n  }\n  return lis;\n}\n\nconst partListCache = new WeakMap<NodePart, Array<KeyedNodePart|null>>();\n\nexport function repeat<T>(\n    items: T[], keyFn: KeyFn<T>, template: ItemTemplate<T>):\n    Directive<NodePart>;\nexport function repeat<T>(\n    items: T[], template: ItemTemplate<T>): Directive<NodePart>;\nexport function repeat<T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T>|ItemTemplate<T>,\n    template?: ItemTemplate<T>,\n    options?: RepeatOptions): Directive<NodePart> {\n  let keyFn: KeyFn<T>;\n  if (arguments.length < 3) {\n    template = keyFnOrTemplate;\n  } else {\n    keyFn = keyFnOrTemplate as KeyFn<T>;\n  }\n\n  if (options == undefined) {\n    options = {} as RepeatOptions;\n  }\n\n  return directive((directivePart: NodePart): void => {\n\n    // Old part list is retrieved from the last render at this part\n    let oldParts = partListCache.get(directivePart) || [];\n\n    // New result list is eagerly generated from items and marked with its key\n    const newResults: Array<KeyedTemplateResult> = [];\n    let index = 0;\n    for (const item of items) {\n      let result = newResults[index] = template !(item, index);\n      result.key = keyFn ? keyFn(item) : index;\n      index++;\n    }\n\n    // Optional pool to reuse items from; when `true` we make a pool and only\n    // use on this update; otherwise user pool passed can be used across updates \n    let pool: Map<any, KeyedNodePart> | undefined =\n      options!.pool || options!.reuse ? new Map() : undefined;\n\n    // New part list will be built up as we go (either reused from old parts or\n    // created for new keys in this render)\n    const newParts: Array<KeyedNodePart> = [];\n\n    // Head and tail pointers to new results and old parts\n    let oldStartIndex = 0;\n    let oldStartPart = oldParts[0];\n    \n    let oldEndIndex = oldParts.length-1;\n    let oldEndPart = oldParts[oldEndIndex];\n\n    let newStartIndex = 0;\n    let newStartResult = newResults[0];\n\n    let newEndIndex = newResults.length-1;\n    let newEndResult = newResults[newEndIndex];\n\n    // key-to-index map for old parts will be lazily generated only when needed\n    let oldPartKeyToIndexMap;\n    // set of indicies in longest incrementing subsequence of old items\n    let oldIndexLIS: Set<number> | null = null;\n\n    function log(msg: string) {\n      return;\n      if (oldParts.length == 0) {\n        return;\n      }\n      const max = Math.max(oldParts.length, newResults.length);\n      const pad = Math.floor(Math.log10(max)) + 2;\n      console.log('+-' + '-'.repeat(max*pad));\n      console.log('| ' + oldParts.map((_,i) => ((i==oldStartIndex && i==oldEndIndex) ? 'se' : i==oldStartIndex ? 's' : i==oldEndIndex ? 'e' : ' ').padStart(pad)).join(''));\n      console.log('| ' + oldParts.map(o=>(o ? o.key : '-').toString().padStart(pad)).join(''));\n      console.log('| ' + newResults.map(o=>o.key.toString().padStart(pad)).join(''));\n      console.log('| ' + newResults.map((_,i) => ((i==newStartIndex && i==newEndIndex) ? 'se' : i==newStartIndex ? 's' : i==newEndIndex ? 'e' : ' ').padStart(pad)).join(''));\n      oldIndexLIS && console.log('| lis: ' + Array.from(oldIndexLIS as Set<number>).sort((a,b)=>a-b).join(' '));\n      console.log('+-' + '-'.repeat(max*pad));\n      console.log(msg);\n    }\n\n    while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {\n      if (oldStartPart == null) {\n        // Old part at head has already been used; skip\n        oldStartPart = oldParts[++oldStartIndex];\n      } else if (oldEndPart == null) {\n        // Old part at tail has already been used; skip\n        oldEndPart = oldParts[--oldEndIndex];\n      } else if (oldStartPart.key == newStartResult.key) {\n        // Old head matches new head; update in place\n        log(`> Heads match ${oldStartIndex}`);\n        newParts[newStartIndex] = updatePart(oldStartPart, newStartResult);\n        oldStartPart = oldParts[++oldStartIndex];\n        newStartResult = newResults[++newStartIndex];\n      } else if (oldEndPart.key == newEndResult.key) {\n        // Old tail matches new tail; update in place\n        log(`> Tails match ${oldEndIndex}`);\n        newParts[newEndIndex] = updatePart(oldEndPart, newEndResult);\n        oldEndPart = oldParts[--oldEndIndex];\n        newEndResult = newResults[--newEndIndex];\n      } else if (oldStartPart.key == newEndResult.key) {\n        // Old head matches new tail; update and move to new tail\n        log(`> Swap ${oldStartIndex}`);\n        newParts[newEndIndex] = updatePart(oldStartPart, newEndResult);\n        movePart(directivePart, oldStartPart, newParts[newEndIndex+1]);\n        oldStartPart = oldParts[++oldStartIndex];\n        newEndResult = newResults[--newEndIndex];\n      } else if (oldEndPart.key == newStartResult.key) {\n        // Old tail matches new head; update and move to new head\n        log(`> Swap ${oldEndIndex}`);\n        newParts[newStartIndex] = updatePart(oldEndPart, newStartResult);\n        movePart(directivePart, oldEndPart, oldStartPart);\n        oldEndPart = oldParts[--oldEndIndex];\n        newStartResult = newResults[++newStartIndex];\n      } else {\n        // Lazily generate key-to-index map for remaining oldParts\n        if (oldPartKeyToIndexMap == undefined) {\n          oldPartKeyToIndexMap = createKeyToIndexMap(oldParts, oldStartIndex, oldEndIndex);\n          // Try removing any unused old parts (continue, since this may\n          // have unblocked the linear part of the update)\n          log(`> Removing unused items`);\n          if (removeUnusedOldParts(oldParts, oldPartKeyToIndexMap, newResults, newStartIndex, newEndIndex, pool)) {\n            oldStartPart = oldParts[oldEndIndex];\n            oldEndPart = oldParts[oldStartIndex];\n            continue;\n          }\n        } else do {\n          // Walk backwards through new results (to make inserting easier) and\n          // check if we have an oldPart for this new result\n          const oldIndex = oldPartKeyToIndexMap.get(newEndResult.key);\n          const oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;\n          if (oldPart == null) {\n            // No old part for this result; create a new one and insert it\n            log(`> New item`);\n            newParts[newEndIndex] = createPart(directivePart, newEndResult, newParts[newEndIndex+1], pool, options!.reuse);\n          } else {\n            // Reuse old part\n            newParts[newEndIndex] = updatePart(oldPart, newEndResult);\n            // Lazily generate longest incrementing subsequnce of new items; we'll\n            // avoid moving these to minimize the number of moves\n            if (oldIndexLIS == undefined && options!.lis) {\n              oldIndexLIS = createOldIndexLIS(oldPartKeyToIndexMap, newResults, newStartIndex, newEndIndex);\n            }\n            // Move into new spot unless part is in LIS\n            if (!oldIndexLIS || !oldIndexLIS.has(oldIndex as number)) {\n              movePart(directivePart, oldPart, newParts[newEndIndex+1]);\n              log(`> Move ${oldIndex}`);\n            } else {\n              log(`> LIS update ${oldIndex}`);\n            }\n            // This marks the old part as having been used, so that it will be \n            // skipped im the first two checks above\n            oldParts[oldIndex as number] = null;\n          }\n          newEndResult = newResults[--newEndIndex];\n        } while (oldIndexLIS && newStartIndex < newEndIndex)\n      }\n    }\n    // Add parts for remaining results\n    while (newStartIndex <= newEndIndex) {\n      log(`> New item`);\n      newParts[newStartIndex] = createPart(directivePart, newStartResult, oldStartPart, pool, options!.reuse);\n      newStartResult = newResults[++newStartIndex];\n    }\n    // Remove any unused old parts\n    if (!oldPartKeyToIndexMap) {\n      while (oldStartIndex <= oldEndIndex) {\n        if (oldStartPart !== null) {\n          log(`> Remove ${oldStartIndex}`);\n          removeOrPoolPart(oldStartPart, pool);\n          oldStartPart = oldParts[++oldStartIndex];\n        }\n      }\n    }\n    // Disconnect any pooled nodes\n    if (pool) {\n      for (let [,part] of pool) {\n        poolPartNodes(part);\n      }\n    }\n    // Save order of new parts for next round\n    partListCache.set(directivePart, newParts);\n\n  });\n}\n"]}