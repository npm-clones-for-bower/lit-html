{"version":3,"file":"repeat-baseline.js","sourceRoot":"","sources":["../src/directives/repeat-baseline.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {TemplateResult} from '../lib/template-result.js';\nimport {createMarker, directive, Directive, NodePart, removeNodes, reparentNodes} from '../lit-html.js';\n\nexport type KeyFn<T> = (item: T) => any;\nexport type ItemTemplate<T> = (item: T, index: number) => any;\n\n// Helper functions for manipulating parts\n// TODO(kschaaf): Refactor into Part API?\nconst createAndInsertPart =\n    (containerPart: NodePart, beforePart?: NodePart): NodePart => {\n      const container = containerPart.startNode.parentNode as Node;\n      const beforeNode = beforePart === undefined ? containerPart.endNode :\n                                                    beforePart.startNode;\n      const startNode = container.insertBefore(createMarker(), beforeNode);\n      container.insertBefore(createMarker(), beforeNode);\n      const newPart = new NodePart(containerPart.templateFactory);\n      newPart.insertAfterNode(startNode);\n      return newPart;\n    };\nconst updatePart = (part: NodePart, result: TemplateResult) => {\n  part.setValue(result);\n  part.commit();\n  return part;\n};\nconst insertPartBefore =\n    (containerPart: NodePart, part: NodePart, ref?: NodePart) => {\n      const container = containerPart.startNode.parentNode as Node;\n      const beforeNode = ref ? ref.startNode : containerPart.endNode;\n      const endNode = part.endNode.nextSibling;\n      if (endNode !== beforeNode) {\n        reparentNodes(container, part.startNode, endNode, beforeNode);\n      }\n    };\nconst removePart = (part: NodePart) => {\n  removeNodes(\n      part.startNode.parentNode!, part.startNode, part.endNode.nextSibling);\n};\nconst generateMap =\n    (list: unknown[], start: number, end: number) => {\n      const map = new Map();\n      for (let i = start; i <= end; i++) {\n        map.set(list[i], i);\n      }\n      return map;\n    }\n\n// Stores previous ordered list of  parts and map of key to index\nconst partListCache = new WeakMap<NodePart, (NodePart | null)[]>();\nconst keyListCache = new WeakMap<NodePart, unknown[]>();\n\nexport function repeat<T>(\n    items: T[], keyFn: KeyFn<T>, template: ItemTemplate<T>):\n    Directive<NodePart>;\nexport function repeat<T>(\n    items: T[], template: ItemTemplate<T>): Directive<NodePart>;\nexport function repeat<T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T>|ItemTemplate<T>,\n    template?: ItemTemplate<T>): Directive<NodePart> {\n  let keyFn: KeyFn<T>;\n  if (arguments.length === 2) {\n    template = keyFnOrTemplate;\n  } else if (arguments.length === 3) {\n    keyFn = keyFnOrTemplate as KeyFn<T>;\n  }\n\n  return directive((containerPart: NodePart): void => {\n    // Old part & key lists and key-to-index map is retrieved from the last\n    // update (associated with the part created for this instance of the\n    // directive)\n    const oldParts = partListCache.get(containerPart) || [];\n    const oldKeys = keyListCache.get(containerPart) || [];\n\n    // New part list will be built up as we go (either reused from old parts or\n    // created for new keys in this update). This is saved in partListCache\n    // at the end of the update.\n    const newParts: NodePart[] = [];\n\n    // New result list is eagerly generated from items along with a parallel\n    // array indicating its key. These are also saved in respective caches at\n    // the end of the update.\n    const newResults: TemplateResult[] = [];\n    const newKeys: unknown[] = [];\n    let index = 0;\n    for (const item of items) {\n      newKeys[index] = keyFn ? keyFn(item) : index;\n      newResults[index] = template !(item, index);\n      index++;\n    }\n\n    // Maps from key to index for current and previous update; these are\n    // generated lazily only when needed (generally, multiple non-contiguous\n    // changes in the list, which can be fairly rare)\n    let newKeyToIndexMap: Map<unknown, number>;\n    let oldKeyToIndexMap: Map<unknown, number>;\n\n    // Head and tail pointers to old parts and new results\n    let oldHead = 0;\n    let oldTail = oldParts.length - 1;\n    let newHead = 0;\n    let newTail = newResults.length - 1;\n\n    // Overview of O(n) reconciliation algorithm (general approach based on\n    // ideas found in ivi, vue, snabbdom, etc.):\n    //\n    // * We start with the list of old parts and new results (and arrays of\n    //   their respective keys), head/tail pointers into each, and we build\n    //   up the new list of parts by updating (and when needed, moving) old\n    //   parts or creating new ones. The initial scenario might look like this\n    //   (for brevity of the diagrams, the numbers in the array reflect \"keys\"\n    //   associated with the old parts or new results, although they are\n    //   actually stored in parallel arrays indexed using the same head/tail\n    //   pointers):\n    //\n    //        oldHead v                 v oldTail\n    //   oldParts:   [0, 1, 2, 3, 4, 5, 6]\n    //   newParts:   [ ,  ,  ,  ,  ,  ,  ]\n    //   newResults: [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new item order\n    //        newHead ^                 ^ newTail\n    //\n    // * Iterate old & new lists from both sides, updating, swapping, or\n    //   removing parts at the head/tail locations until neither head nor tail\n    //   can move.\n    //\n    // * Example below: keys at head pointers match, so update old part 0 in-\n    //   place (no need to move it) and record part 0 in the `newParts` list.\n    //   The last thing we do is advance the `oldHead` and `newHead` pointers\n    //   (will be reflected in the next diagram).\n    //\n    //        oldHead v                 v oldTail\n    //   oldParts:   [0, 1, 2, 3, 4, 5, 6]\n    //   newParts:   [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0 and\n    //   newResults: [0, 2, 1, 4, 3, 7, 6]    advance both oldHead & newHead\n    //        newHead ^                 ^ newTail\n    //\n    // * Example below: head pointers don't match, but tail pointers do, so\n    //   update part 6 in place (no need to move it), and record part 6 in the\n    //   `newParts` list. Last, advance the `oldTail` and `oldHead` pointers.\n    //\n    //           oldHead v              v oldTail\n    //   oldParts:   [0, 1, 2, 3, 4, 5, 6]\n    //   newParts:   [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6 and\n    //   newResults: [0, 2, 1, 4, 3, 7, 6]    advance both oldTail & newTail\n    //           newHead ^              ^ newTail\n    //\n    // * Example below: neither head nor tail match; next check if one of the\n    //   old head/tail items was removed.  The key at `oldTail` was removed\n    //   (no longer in the `newKeyToIndexMap`), so remove that part from the\n    //   DOM and advance just the `oldTail` pointer.\n    //\n    //           oldHead v           v oldTail\n    //   oldParts:   [0, 1, 2, 3, 4, 5, 6]\n    //   newParts:   [0,  ,  ,  ,  ,  , 6] <- 5 not in new map; remove 5 and\n    //   newResults: [0, 2, 1, 4, 3, 7, 6]    advance oldTail\n    //           newHead ^           ^ newTail\n    //\n    // * Once head and tail cannot move, any mismatches are due to either new or\n    //   moved items; if a new key is in the previous \"old key to old index\"\n    //   map, find the old part and move it to the new location, otherwise\n    //   create and insert a new part. Note that when moving an old part we\n    //   null its position in the oldParts array if it lies between the head\n    //   and tail so we know to skip it when the pointers get there.\n    //\n    // * Example below: neither head nor tail match, and neither were removed;\n    //   so find the `newHead` key in the `oldKeyToIndexMap`, and move that old\n    //   part's DOM into the next head position (before `oldParts[oldHead]`).\n    //   Last, null the part in the `oldPart` array since it was somewhere in\n    //   the remaining oldParts still to be scanned (between the head and tail\n    //   pointers) so that we know to skip that old part on future iterations.\n    //\n    //           oldHead v        v oldTail\n    //   oldParts:   [0, 1, -, 3, 4, 5, 6]\n    //   newParts:   [0, 2,  ,  ,  ,  , 6] <- stuck; update & move 2 into place\n    //   newResults: [0, 2, 1, 4, 3, 7, 6]    and advance newHead\n    //           newHead ^           ^ newTail\n    //\n    // * Note that for moves/insertions like the one above, a part inserted at\n    //   the head pointer is inserted before the current `oldParts[oldHead]`,\n    //   and a part inserted at the tail pointer is inserted before\n    //   `newParts[newHead+1]`. The seeming asymmetry lies in the fact that new\n    //   parts are moved into place outside in, so to the right of the head\n    //   pointer are old parts, and to the right of the tail pointer are new\n    //   parts.\n    //\n    // * We always restart back from the top of the algorithm, allowing matching\n    //   and simple updates in place to continue...\n    //\n    // * Example below: the head pointers once again match, so simply update\n    //   part 1 and record it in the `newParts` array.  Last, advance both head\n    //   pointers.\n    //\n    //           oldHead v        v oldTail\n    //   oldParts:   [0, 1, -, 3, 4, 5, 6]\n    //   newParts:   [0, 2, 1,  ,  ,  , 6] <- heads matched; update 1 and\n    //   newResults: [0, 2, 1, 4, 3, 7, 6]    advance both oldHead & newHead\n    //              newHead ^        ^ newTail\n    //\n    // * As mentioned above, items that were moved as a result of being stuck\n    //   (the final else clause in the code below) are marked with null, so we\n    //   always advance old pointers over these so we're comparing the next\n    //   actual old value on either end.\n    //\n    // * Example below: `oldHead` is null (already placed in newParts), so\n    //   advance `oldHead`.\n    //\n    //              oldHead v     v oldTail\n    //   oldParts:   [0, 1, -, 3, 4, 5, 6] // old head already used; advance\n    //   newParts:   [0, 2, 1,  ,  ,  , 6] // oldHead\n    //   newResults: [0, 2, 1, 4, 3, 7, 6]\n    //                 newHead ^     ^ newTail\n    //\n    // * Note it's not critical to mark old parts as null when they are moved\n    //   from head to tail or tail to head, since they will be outside the\n    //   pointer range and never visited again.\n    //\n    // * Example below: Here the old tail key matches the new head key, so\n    //   the part at the `oldTail` position and move its dom to the new\n    //   head position (before `oldParts[oldHead]`). Last, advance `oldTail`\n    //   and `newHead` pointers.\n    //\n    //                 oldHead v  v oldTail\n    //   oldParts:   [0, 1, -, 3, 4, 5, 6]\n    //   newParts:   [0, 2, 1, 4,  ,  , 6] <- old tail matches new head: update\n    //   newResults: [0, 2, 1, 4, 3, 7, 6]   & move 4, advance oldTail & newHead\n    //                 newHead ^     ^ newTail\n    //\n    // * Example below: Old and new head keys match, so update the old head\n    //   part in place, and advance the `oldHead` and `newHead` pointers.\n    //\n    //                 oldHead v oldTail\n    //   oldParts:   [0, 1, -, 3, 4, 5, 6]\n    //   newParts:   [0, 2, 1, 4, 3,   ,6] <- heads match: update 3 and advance\n    //   newResults: [0, 2, 1, 4, 3, 7, 6]    oldHead & newHead\n    //                    newHead ^  ^ newTail\n    //\n    // * Once the new or old pointers move past each other then all we have\n    //   left is additions (if old list exhausted) or removals (if new list\n    //   exhausted). Those are handled in the final while loops at the end.\n    //\n    // * Example below: `oldHead` exceeded `oldTail`, so we're done with the\n    //   main loop.  Create the remaining part and insert it at the new head\n    //   position, and the update is complete.\n    //\n    //                   (oldHead > oldTail)\n    //   oldParts:   [0, 1, -, 3, 4, 5, 6]\n    //   newParts:   [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7\n    //   newResults: [0, 2, 1, 4, 3, 7, 6]\n    //                       newHead ^ newTail\n    //\n    // * Note that the order of the if/else clauses is not important to the\n    //   algorithm, as long as the null checks come first (to ensure we're\n    //   always working on valid old parts) and that the final else clause\n    //   comes last (since that's where the expensive moves occur). The\n    //   order of remaining clauses is is just a simple guess at which cases\n    //   will be most common.\n    //\n    // * TODO(kschaaf) Note, we could calculate the longest increasing\n    //   subsequence (LIS) of old items in new position, and only move those not\n    //   in the LIS set. However that costs O(nlogn) time and adds a bit more\n    //   code, and only helps make rare types of mutations require fewer moves.\n    //   The above handles removes, adds, reversal, swaps, and single moves of\n    //   contiguous items in linear time, in the minimum number of moves. As\n    //   the number of multiple moves where LIS might help approaches a random\n    //   shuffle, the LIS optimization becomes less helpful, so it seems not\n    //   worth the code at this point. Could reconsider if a compelling case\n    //   arises.\n\n    while (oldHead <= oldTail && newHead <= newTail) {\n      if (oldParts[oldHead] === null) {\n        // `null` means old part at head has already been used below; skip\n        oldHead++;\n      } else if (oldParts[oldTail] === null) {\n        // `null` means old part at tail has already been used below; skip\n        oldTail--;\n      } else if (oldKeys[oldHead] === newKeys[newHead]) {\n        // Old head matches new head; update in place\n        newParts[newHead] = updatePart(oldParts[oldHead]!, newResults[newHead]);\n        oldHead++;\n        newHead++;\n      } else if (oldKeys[oldTail] === newKeys[newTail]) {\n        // Old tail matches new tail; update in place\n        newParts[newTail] = updatePart(oldParts[oldTail]!, newResults[newTail]);\n        oldTail--;\n        newTail--;\n      } else if (oldKeys[oldHead] === newKeys[newTail]) {\n        // Old head matches new tail; update and move to new tail\n        newParts[newTail] = updatePart(oldParts[oldHead]!, newResults[newTail]);\n        insertPartBefore(\n            containerPart, oldParts[oldHead]!, newParts[newTail + 1]);\n        oldHead++;\n        newTail--;\n      } else {\n        if (newKeyToIndexMap! === undefined) {\n          newKeyToIndexMap = generateMap(newKeys, newHead, newTail);\n          oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);\n        }\n        if (!newKeyToIndexMap!.has(oldKeys[oldHead])) {\n          // Old head is no longer in new list; remove\n          removePart(oldParts[oldHead]!);\n          oldHead++;\n        } else if (!newKeyToIndexMap!.has(oldKeys[oldTail])) {\n          // Old tail is no longer in new list; remove\n          removePart(oldParts[oldTail]!);\n          oldTail--;\n        } else if (oldKeys[oldTail] === newKeys[newHead]) {\n          // Old tail matches new head; update and move to new head\n          newParts[newHead] =\n              updatePart(oldParts[oldTail]!, newResults[newHead]);\n          insertPartBefore(\n              containerPart, oldParts[oldTail]!, oldParts[oldHead]!);\n          oldTail--;\n          newHead++;\n        } else {\n          // Any mismatches at this point are due to additions or moves; see if\n          // we have an old part we can reuse and move into place\n          const oldIndex = oldKeyToIndexMap!.get(newKeys[newHead]);\n          const oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;\n          if (oldPart == null) {\n            // No old part for this result; create a new one and insert it\n            let newPart =\n                createAndInsertPart(containerPart, oldParts[oldHead]!);\n            updatePart(newPart, newResults[newHead]);\n            newParts[newHead] = newPart;\n          } else {\n            // Reuse old part\n            newParts[newHead] = updatePart(oldPart, newResults[newHead]);\n            insertPartBefore(containerPart, oldPart, oldParts[oldHead]!);\n            // This marks the old part as having been used, so that it will be\n            // skipped in the first two checks above\n            oldParts[oldIndex as number] = null;\n          }\n          newHead++;\n        }\n      }\n    }\n    // Add parts for any remaining new results\n    while (newHead <= newTail) {\n      const newPart = createAndInsertPart(containerPart, oldParts[oldHead]!);\n      updatePart(newPart, newResults[newHead]);\n      newParts[newHead++] = newPart;\n    }\n    // Remove any remaining unused old parts\n    while (oldHead <= oldTail) {\n      const oldPart = oldParts[oldHead++];\n      if (oldPart !== null) {\n        removePart(oldPart);\n      }\n    }\n    // Save order of new parts for next round\n    partListCache.set(containerPart, newParts);\n    keyListCache.set(containerPart, newKeys);\n  });\n}\n"]}