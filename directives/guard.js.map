{"version":3,"file":"guard.js","sourceRoot":"","sources":["../src/directives/guard.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;GAYG;AAEH,OAAO,EAAC,SAAS,EAAO,MAAM,gBAAgB,CAAC;AAE/C,MAAM,mBAAmB,GAAG,IAAI,OAAO,EAAa,CAAC;AAErD;;;;;;;;;;;;;;;;;;GAkBG;AACH,MAAM,CAAC,MAAM,KAAK,GACd,SAAS,CAAC,CAAC,UAAe,EAAE,OAAkB,EAAE,EAAE,CAAC,CAAC,IAAU,EAAQ,EAAE;IACtE,kCAAkC;IAClC,IAAI,mBAAmB,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,UAAU,EAAE;QAChD,OAAO;KACR;IAED,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC,CAAC;IACzB,mBAAmB,CAAC,GAAG,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;AAC5C,CAAC,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {directive, Part} from '../lit-html.js';\n\nconst previousExpressions = new WeakMap<Part, any>();\n\n/**\n * Creates a guard directive. Prevents any re-render until the identity of the\n * expression changes, for example when a primitive changes value or when an\n * object reference changes.\n *\n * This useful with immutable data patterns, by preventing expensive work until\n * data updates. Example:\n *\n * html`\n *   <div>\n *     ${guard(items, () => items.map(item => html`${item}`))}\n *   </div>\n * `\n *\n * In this case, items are mapped over only when the array reference changes.\n *\n * @param expression the expression to check before re-rendering\n * @param valueFn function which returns the render value\n */\nexport const guard =\n    directive((expression: any, valueFn: () => any) => (part: Part): void => {\n      // Dirty check previous expression\n      if (previousExpressions.get(part) === expression) {\n        return;\n      }\n\n      part.setValue(valueFn());\n      previousExpressions.set(part, expression);\n    });\n"]}