{"version":3,"file":"repeat-ab.js","sourceRoot":"","sources":["../src/directives/repeat-ab.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {directive, Directive, NodePart, removeNodes, reparentNodes, TemplateFactory} from '../lit-html.js';\nimport { TemplateResult } from '../lib/shady-render.js';\n\nexport type KeyFn<T> = (item: T) => any;\nexport type ItemTemplate<T> = (item: T, index: number) => any;\n\n// Extension of NodePart to add concept of keying\n// TODO(kschaaf): Should keying be part of part API?\nclass KeyedNodePart extends NodePart {\n  key: any;\n  constructor(templateFactory: TemplateFactory, key: any ) {\n    super(templateFactory);\n    this.key = key;\n  }\n}\n\n// Extension of TemplateResult to add concept of keying\n// TODO(kschaaf): Could be a WeakMap; worth it?\n// TODO(kschaaf): Should keying be part of template result API?\ninterface KeyedTemplateResult extends TemplateResult {\n  key: any;\n}\n\n// Iterates a subset of a parts or results array and returns a map of\n// keys to index in original array\nfunction createKeyToIndexMap(items: Array<KeyedNodePart|KeyedTemplateResult|null>, start: number, end: number) {\n  const map = new Map<any, number>();\n  for (let i=start; i<=end; i++) {\n    const item = items[i];\n    if (item !== null) {\n      map.set(item.key, i);\n    }\n  }\n  return map;\n}\n\n// Helper functions for manipulating parts\n// TODO(kschaaf): Refactor into Part API?\nfunction createPart(parentPart: NodePart, result: KeyedTemplateResult,\n  beforePart?: NodePart | null): KeyedNodePart {\n  const container = parentPart.startNode.parentNode as Node;\n  const beforeNode = beforePart ? beforePart.startNode : parentPart.endNode;\n  const startNode = document.createComment('');\n  const endNode = document.createComment('');\n  container.insertBefore(startNode, beforeNode);\n  container.insertBefore(endNode, beforeNode);\n  const newPart = new KeyedNodePart(parentPart.templateFactory, result.key);\n  newPart.insertAfterNode(startNode);\n  updatePart(newPart, result);\n  return newPart;\n}\nfunction updatePart(part: KeyedNodePart, result: TemplateResult) {\n  part.setValue(result);\n  part.commit();\n  return part;\n}\nfunction movePart(parentPart: NodePart, partToMove: NodePart, beforePart: NodePart | null | undefined) {\n  const container = parentPart.startNode.parentNode as Node;\n  const beforeNode = beforePart ? beforePart.startNode : parentPart.endNode;\n  const endNode = partToMove.endNode.nextSibling;\n  if (endNode !== beforeNode) {\n    reparentNodes(container, partToMove.startNode, endNode, beforeNode);\n  }\n}\nfunction removePart(part: NodePart) {\n  removeNodes(part.startNode.parentNode as Node, part.startNode, part.endNode.nextSibling);\n}\n\n// Removes old parts not in the specified range of new results\nfunction removeUnusedOldParts(\n  oldParts: Array<KeyedNodePart|null>, oldPartKeyToIndexMap: Map<any, number>,\n  newResults: Array<KeyedTemplateResult>, newStartIndex: number, newEndIndex: number) {\n  let removed = false;\n  const newResultKeyToIndexMap = createKeyToIndexMap(newResults, newStartIndex, newEndIndex);\n  for (let [key, oldPartIdx] of oldPartKeyToIndexMap) {\n    if (!newResultKeyToIndexMap.has(key)) {\n      // Assumption: this fn is run once before any moves have happened, so\n      // no items in this range can be null yet\n      const oldPart = oldParts[oldPartIdx] as KeyedNodePart;\n      removePart(oldPart);\n      oldParts[oldPartIdx] = null;\n      removed = true;\n    }\n  }\n  return removed;\n}\n\n// Stores previous ordered list of keyed parts\nconst partListCache = new WeakMap<NodePart, Array<KeyedNodePart|null>>();\n\nexport function repeat<T>(\n    items: T[], keyFn: KeyFn<T>, template: ItemTemplate<T>):\n    Directive<NodePart>;\nexport function repeat<T>(\n    items: T[], template: ItemTemplate<T>): Directive<NodePart>;\nexport function repeat<T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T>|ItemTemplate<T>,\n    template?: ItemTemplate<T>): Directive<NodePart> {\n  let keyFn: KeyFn<T>;\n  if (arguments.length < 3) {\n    template = keyFnOrTemplate;\n  } else {\n    keyFn = keyFnOrTemplate as KeyFn<T>;\n  }\n\n  return directive((directivePart: NodePart): void => {\n\n    // Old part list is retrieved from the last render at this part\n    let oldParts = partListCache.get(directivePart) || [];\n\n    // New part list will be built up as we go (either reused from old parts or\n    // created for new keys in this render). This is saved in partListCache\n    // at the end of the update\n    const newParts: Array<KeyedNodePart> = [];\n\n    // New result list is eagerly generated from items and marked with its key\n    const newResults: Array<KeyedTemplateResult> = [];\n    let index = 0;\n    for (let item of items) {\n      let result = newResults[index] = template !(item, index);\n      result.key = keyFn ? keyFn(item) : index;\n      index++;\n    }\n\n    // Head and tail pointers to new results and old parts\n    let oldStartIndex = 0;\n    let oldStartPart = oldParts[0];\n    \n    let oldEndIndex = oldParts.length-1;\n    let oldEndPart = oldParts[oldEndIndex];\n\n    let newStartIndex = 0;\n    let newStartResult = newResults[0];\n\n    let newEndIndex = newResults.length-1;\n    let newEndResult = newResults[newEndIndex];\n\n    // key-to-index map for old parts will be lazily generated only when needed\n    let oldPartKeyToIndexMap;\n\n    // Overview of O(n) reconciliation algorithm:\n    // * Iterate old & new lists from both sides, updating or swapping items\n    //   in place until neither head nor tail can move; at this point (the \n    //   final else case), move into more expensive operations (general concept\n    //   based on ideas in https://github.com/localvoid/ivi/blob/1ad5a1/packages/ivi/src/vdom/sync.ts#L502)\n    // * Create a map of \"old key to old index\" of the remaining subset of old\n    //   parts. This will be used to know when an old part can be reused vs.\n    //   when we need to make a new one.\n    // * As an optimization, eagerly remove all removed parts by making a \"new\n    //   key to new index\" map, and then iterating the old map and removing\n    //   any old items not in the new map. Then continue back to the top of the\n    //   algorithm since removing items may have allowed the head/tail trimming\n    //   to continue.\n    // * Once head and tail cannot move, any mismatches are due to either new or\n    //   moved items; create and insert new items, or else move old part to new\n    //   position using the \"old key to old index\" map.\n    // * TODO(kschaaf) Note, we could calculate the longest increasing\n    //   subsequence (LIS) of old items in new position, and only move those not\n    //   in the LIS set. However that costs O(nlogn) time and adds a bit more\n    //   code, and only helps make rare types of mutations require fewer moves.\n    //   The above handles removes, adds, reversal, swaps, and single moves of\n    //   contiguous items in linear time in the minimum number of moves. As\n    //   the number of multiple moves where LIS might help approaches a random\n    //   shuffle, the LIS optimization washes out, so it seems not worth the\n    //   code at this point, but could consider if a compelling case is shown.\n    while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {\n      if (oldStartPart == null) {\n        // Old part at head has already been used; skip\n        oldStartPart = oldParts[++oldStartIndex];\n      } else if (oldEndPart == null) {\n        // Old part at tail has already been used; skip\n        oldEndPart = oldParts[--oldEndIndex];\n      } else if (oldStartPart.key == newStartResult.key) {\n        // Old head matches new head; update in place\n        newParts[newStartIndex] = updatePart(oldStartPart, newStartResult);\n        oldStartPart = oldParts[++oldStartIndex];\n        newStartResult = newResults[++newStartIndex];\n      } else if (oldEndPart.key == newEndResult.key) {\n        // Old tail matches new tail; update in place\n        newParts[newEndIndex] = updatePart(oldEndPart, newEndResult);\n        oldEndPart = oldParts[--oldEndIndex];\n        newEndResult = newResults[--newEndIndex];\n      } else if (oldStartPart.key == newEndResult.key) {\n        // Old head matches new tail; update and move to new tail\n        newParts[newEndIndex] = updatePart(oldStartPart, newEndResult);\n        movePart(directivePart, oldStartPart, newParts[newEndIndex+1]);\n        oldStartPart = oldParts[++oldStartIndex];\n        newEndResult = newResults[--newEndIndex];\n      } else if (oldEndPart.key == newStartResult.key) {\n        // Old tail matches new head; update and move to new head\n        newParts[newStartIndex] = updatePart(oldEndPart, newStartResult);\n        movePart(directivePart, oldEndPart, oldStartPart);\n        oldEndPart = oldParts[--oldEndIndex];\n        newStartResult = newResults[++newStartIndex];\n      } else {\n        // Lazily generate key-to-index map for remaining oldParts\n        if (oldPartKeyToIndexMap == undefined) {\n          oldPartKeyToIndexMap = createKeyToIndexMap(oldParts, oldStartIndex, oldEndIndex);\n          // Try removing any unused old parts\n          if (removeUnusedOldParts(oldParts, oldPartKeyToIndexMap, newResults, newStartIndex, newEndIndex)) {\n            oldStartPart = oldParts[oldEndIndex];\n            oldEndPart = oldParts[oldStartIndex];\n            // continue to top of loop, since this may have unblocked head/tail\n            // trimming cases above\n            continue;\n          }\n        }\n        // Any mismatches at this point are due to additions or moves; see if\n        // we have an old part we can reuse and move into place\n        const oldIndex = oldPartKeyToIndexMap.get(newEndResult.key);\n        const oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;\n        if (oldPart == null) {\n          // No old part for this result; create a new one and insert it\n          newParts[newEndIndex] = createPart(directivePart, newEndResult, newParts[newEndIndex+1]);\n        } else {\n          // Reuse old part\n          newParts[newEndIndex] = updatePart(oldPart, newEndResult);\n          movePart(directivePart, oldPart, newParts[newEndIndex+1]);\n          // This marks the old part as having been used, so that it will be \n          // skipped in the first two checks above\n          oldParts[oldIndex as number] = null;\n        }\n        newEndResult = newResults[--newEndIndex];\n      }\n    }\n    // Add parts for remaining results\n    while (newStartIndex <= newEndIndex) {\n      newParts[newStartIndex] = createPart(directivePart, newStartResult, oldStartPart);\n      newStartResult = newResults[++newStartIndex];\n    }\n    // Remove any unused old parts (only needed if we didn't need to\n    // generate the `oldPartKeyToIndexMap` above, since that's also when we\n    // eagerly remove items)\n    if (!oldPartKeyToIndexMap) {\n      while (oldStartIndex <= oldEndIndex) {\n        if (oldStartPart !== null) {\n          removePart(oldStartPart);\n        }\n        oldStartPart = oldParts[++oldStartIndex];\n      }\n    }\n    // Save order of new parts for next round\n    partListCache.set(directivePart, newParts);\n\n  });\n}\n"]}