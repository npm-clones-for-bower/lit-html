{"version":3,"file":"repeatSimple.js","sourceRoot":"","sources":["../src/directives/repeatSimple.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {directive, Directive, NodePart, removeNodes, reparentNodes, TemplateFactory} from '../lit-html.js';\nimport { TemplateResult } from '../lib/shady-render.js';\n\nexport type KeyFn<T> = (item: T) => any;\nexport type ItemTemplate<T> = (item: T, index: number) => any;\n\nclass KeyedNodePart extends NodePart {\n  key: any;\n  constructor(templateFactory: TemplateFactory, key: any ) {\n    super(templateFactory);\n    this.key = key;\n  }\n}\n\ninterface KeyedTemplateResult extends TemplateResult {\n  key: any;\n}\n\nfunction createPart(parentPart: NodePart, result: KeyedTemplateResult,\n  beforePart?: NodePart | null | undefined): KeyedNodePart {\n  const container = parentPart.startNode.parentNode as Node;\n  const beforeNode = beforePart ? beforePart.startNode : parentPart.endNode;\n  const startNode = document.createComment('');\n  const endNode = document.createComment('');\n  container.insertBefore(startNode, beforeNode);\n  container.insertBefore(endNode, beforeNode);\n  const newPart = new KeyedNodePart(parentPart.templateFactory, result.key);\n  newPart.insertAfterNode(startNode);\n  updatePart(newPart, result);\n  return newPart;\n}\n\nfunction updatePart(part: KeyedNodePart, result: TemplateResult) {\n  part.setValue(result);\n  part.commit();\n  return part;\n}\n\nfunction movePart(parentPart: NodePart, partToMove: NodePart, beforePart: NodePart | null | undefined) {\n  const container = parentPart.startNode.parentNode as Node;\n  const beforeNode = beforePart ? beforePart.startNode : parentPart.endNode;\n  const endNode = partToMove.endNode.nextSibling;\n  if (endNode !== beforeNode) {\n    reparentNodes(container, partToMove.startNode, endNode, beforeNode);\n  }\n}\n\nfunction removePart(part: KeyedNodePart) {\n  removeNodes(part.startNode.parentNode as Node, part.startNode, part.endNode.nextSibling);\n}\n\nfunction createKeyToIndexMap(items: Array<KeyedNodePart|KeyedTemplateResult|null>, start: number, end: number) {\n  const map = new Map<any, number>();\n  for (let i=start; i<=end; i++) {\n    const item = items[i];\n    if (item !== null) {\n      map.set(item.key, i);\n    }\n  }\n  return map;\n}\n\nfunction removeUnusedOldParts(\n  oldParts: Array<KeyedNodePart|null>, oldPartKeyToIndexMap: Map<any, number>,\n  newResults: Array<KeyedTemplateResult>, newStartIndex: number, newEndIndex: number) {\n  let removed = 0;\n  const newResultKeyToIndexMap = createKeyToIndexMap(newResults, newStartIndex, newEndIndex);\n  for (let [key, oldPartIdx] of oldPartKeyToIndexMap) {\n    if (!newResultKeyToIndexMap.has(key)) {\n      // parts in this range are guaranteed to be non-null\n      const oldPart = oldParts[oldPartIdx] as KeyedNodePart;\n      removePart(oldPart);\n      oldParts[oldPartIdx] = null;\n      removed++;\n    }\n  }\n  return Boolean(removed);\n}\n\nconst partListCache = new WeakMap<NodePart, Array<KeyedNodePart|null>>();\n\nexport function repeat<T>(\n    items: T[], keyFn: KeyFn<T>, template: ItemTemplate<T>):\n    Directive<NodePart>;\nexport function repeat<T>(\n    items: T[], template: ItemTemplate<T>): Directive<NodePart>;\nexport function repeat<T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T>|ItemTemplate<T>,\n    template?: ItemTemplate<T>): Directive<NodePart> {\n  let keyFn: KeyFn<T>;\n  if (arguments.length < 3) {\n    template = keyFnOrTemplate;\n  } else {\n    keyFn = keyFnOrTemplate as KeyFn<T>;\n  }\n\n  return directive((directivePart: NodePart): void => {\n\n    // Old part list is retrieved from the last render at this part\n    let oldParts = partListCache.get(directivePart) || [];\n\n    // New result list is eagerly generated from items and marked with its key\n    const newResults: Array<KeyedTemplateResult> = [];\n    let index = 0;\n    for (const item of items) {\n      let result = newResults[index] = template !(item, index);\n      result.key = keyFn ? keyFn(item) : index;\n      index++;\n    }\n\n    // New part list will be built up as we go (either reused from old parts or\n    // created for new keys in this render)\n    const newParts: Array<KeyedNodePart> = [];\n\n    // Head and tail pointers to new results and old parts\n    let oldStartIndex = 0;\n    let oldStartPart = oldParts[0];\n    \n    let oldEndIndex = oldParts.length-1;\n    let oldEndPart = oldParts[oldEndIndex];\n\n    let newStartIndex = 0;\n    let newStartResult = newResults[0];\n\n    let newEndIndex = newResults.length-1;\n    let newEndResult = newResults[newEndIndex];\n\n    // key-to-index map for old parts will be lazily generated only when needed\n    let oldPartKeyToIndexMap;\n\n    while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {\n      if (oldStartPart == null) {\n        // Old part at head has already been used; skip\n        oldStartPart = oldParts[++oldStartIndex];\n      } else if (oldEndPart == null) {\n        // Old part at tail has already been used; skip\n        oldEndPart = oldParts[--oldEndIndex];\n      } else if (oldStartPart.key == newStartResult.key) {\n        // Old head matches new head; update in place\n        newParts[newStartIndex] = updatePart(oldStartPart, newStartResult);\n        oldStartPart = oldParts[++oldStartIndex];\n        newStartResult = newResults[++newStartIndex];\n      } else if (oldEndPart.key == newEndResult.key) {\n        // Old tail matches new tail; update in place\n        newParts[newEndIndex] = updatePart(oldEndPart, newEndResult);\n        oldEndPart = oldParts[--oldEndIndex];\n        newEndResult = newResults[--newEndIndex];\n      } else if (oldStartPart.key == newEndResult.key) {\n        // Old head matches new tail; update and move to new tail\n        newParts[newEndIndex] = updatePart(oldStartPart, newEndResult);\n        movePart(directivePart, oldStartPart, newParts[newEndIndex+1]);\n        oldStartPart = oldParts[++oldStartIndex];\n        newEndResult = newResults[--newEndIndex];\n      } else if (oldEndPart.key == newStartResult.key) {\n        // Old tail matches new head; update and move to new head\n        newParts[newStartIndex] = updatePart(oldEndPart, newStartResult);\n        movePart(directivePart, oldEndPart, oldStartPart);\n        oldEndPart = oldParts[--oldEndIndex];\n        newStartResult = newResults[++newStartIndex];\n      } else {\n        // Lazily generate key-to-index map for remaining oldParts\n        if (oldPartKeyToIndexMap == undefined) {\n          oldPartKeyToIndexMap = createKeyToIndexMap(oldParts, oldStartIndex, oldEndIndex);\n          // Try removing any unused old parts (continue, since this may\n          // have unblocked the linear part of the update)\n          if (removeUnusedOldParts(oldParts, oldPartKeyToIndexMap, newResults, newStartIndex, newEndIndex)) {\n            oldStartPart = oldParts[oldEndIndex];\n            oldEndPart = oldParts[oldStartIndex];\n            continue;\n          }\n        }\n        const oldIndex = oldPartKeyToIndexMap.get(newEndResult.key);\n        const oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;\n        if (oldPart == null) {\n          // No old part for this result; create a new one and insert it\n          newParts[newEndIndex] = createPart(directivePart, newEndResult, newParts[newEndIndex+1]);\n        } else {\n          // Reuse old part\n          newParts[newEndIndex] = updatePart(oldPart, newEndResult);\n          movePart(directivePart, oldPart, newParts[newEndIndex+1]);\n          // This marks the old part as having been used, so that it will be \n          // skipped im the first two checks above\n          oldParts[oldIndex as number] = null;\n        }\n        newEndResult = newResults[--newEndIndex];\n      }\n    }\n    // Add parts for remaining results\n    while (newStartIndex <= newEndIndex) {\n      newParts[newStartIndex] = createPart(directivePart, newStartResult, oldStartPart);\n      newStartResult = newResults[++newStartIndex];\n    }\n    // Remove any unused old parts\n    if (!oldPartKeyToIndexMap) {\n      while (oldStartIndex <= oldEndIndex) {\n        if (oldStartPart !== null) {\n          removePart(oldStartPart);\n          oldStartPart = oldParts[++oldStartIndex];\n        }\n      }\n    }\n    // Save order of new parts for next round\n    partListCache.set(directivePart, newParts);\n\n  });\n}\n"]}