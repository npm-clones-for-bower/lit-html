{"version":3,"file":"repeat-references.key.js","sourceRoot":"","sources":["../src/directives/repeat-references.key.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {TemplateResult} from '../lib/template-result.js';\nimport {createMarker, directive, Directive, NodePart, removeNodes, reparentNodes} from '../lit-html.js';\n\nexport type KeyFn<T> = (item: T) => any;\nexport type ItemTemplate<T> = (item: T, index: number) => any;\n\ndeclare module '../lib/parts.js' {\n  interface NodePart {\n    key: any;\n  }\n}\ndeclare module '../lib/template-result.js' {\n  interface TemplateResult {\n    key: any;\n  }\n}\n\n// Helper functions for manipulating parts\n// TODO(kschaaf): Refactor into Part API?\nconst createAndInsertPart =\n    (containerPart: NodePart, beforePart?: NodePart): NodePart => {\n      const container = containerPart.startNode.parentNode as Node;\n      const beforeNode = beforePart === undefined ? containerPart.endNode :\n                                                    beforePart.startNode;\n      const startNode = container.insertBefore(createMarker(), beforeNode);\n      container.insertBefore(createMarker(), beforeNode);\n      const newPart = new NodePart(containerPart.templateFactory);\n      newPart.insertAfterNode(startNode);\n      return newPart;\n    };\nconst updatePart = (part: NodePart, result: TemplateResult) => {\n  part.setValue(result);\n  part.commit();\n  return part;\n};\nconst insertPartBefore =\n    (containerPart: NodePart, part: NodePart, ref?: NodePart) => {\n      const container = containerPart.startNode.parentNode as Node;\n      const beforeNode = ref ? ref.startNode : containerPart.endNode;\n      const endNode = part.endNode.nextSibling;\n      if (endNode !== beforeNode) {\n        reparentNodes(container, part.startNode, endNode, beforeNode);\n      }\n    };\nconst removePart =\n    (part: NodePart) => {\n      removeNodes(\n          part.startNode.parentNode!, part.startNode, part.endNode.nextSibling);\n    }\n\n// Stores previous ordered list of  parts and map of key to index\nconst partListCache = new WeakMap<NodePart, (NodePart | null)[]>();\n// const keyListCache = new WeakMap<NodePart, unknown[]>();\nconst keyToIndexMapCache = new WeakMap<NodePart, Map<unknown, number>>();\n\nexport function repeat<T>(\n    items: T[], keyFn: KeyFn<T>, template: ItemTemplate<T>):\n    Directive<NodePart>;\nexport function repeat<T>(\n    items: T[], template: ItemTemplate<T>): Directive<NodePart>;\nexport function repeat<T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T>|ItemTemplate<T>,\n    template?: ItemTemplate<T>): Directive<NodePart> {\n  let keyFn: KeyFn<T>;\n  if (arguments.length === 2) {\n    template = keyFnOrTemplate;\n  } else if (arguments.length === 3) {\n    keyFn = keyFnOrTemplate as KeyFn<T>;\n  }\n\n  return directive((containerPart: NodePart): void => {\n    // Old part & key lists and key-to-index map is retrieved from the last\n    // update (associated with the part created for this instance of the\n    // directive)\n    const oldParts = partListCache.get(containerPart) || [];\n    // const oldKeys = keyListCache.get(containerPart) || [];\n    const oldKeyToIndexMap = keyToIndexMapCache.get(containerPart) || new Map();\n\n    // New part list will be built up as we go (either reused from old parts or\n    // created for new keys in this update). This is saved in partListCache\n    // at the end of the update.\n    const newParts: NodePart[] = [];\n\n    // New result list is eagerly generated from items along with a parallel\n    // array indicating its key, and a map from key back to index.  These are\n    // also saved in respective caches at the end of the update.\n    const newResults: TemplateResult[] = [];\n    const newKeyToIndexMap: Map<any, number> = new Map();\n    // const newKeys: unknown[] = [];\n    let index = 0;\n    for (const item of items) {\n      const key = keyFn ? keyFn(item) : index;\n      if (newKeyToIndexMap.has(key)) {\n        console.warn(`Duplicate key '${\n            key}' detected in repeat; behavior is undefined.`);\n      } else {\n        // newKeys[index] = key;\n        // newResults[index] = template !(item, index);\n        const result = template !(item, index);\n        result.key = key;\n        newResults[index] = result;\n        newKeyToIndexMap.set(key, newKeyToIndexMap.size);\n      }\n      index++;\n    }\n\n    // Head and tail pointers to old parts and new results\n    let oldHead = 0;\n    let oldTail = oldParts.length - 1;\n    let oldHeadPart = oldParts[0];\n    let oldTailPart = oldParts[oldTail];\n    // let oldHeadKey = oldKeys[0];\n    // let oldTailKey = oldKeys[oldTail];\n    let newHead = 0;\n    let newTail = newResults.length - 1;\n    let newHeadResult = newResults[0];\n    let newTailResult = newResults[newTail];\n    // let newHeadKey = newKeys[0];\n    // let newTailKey = newKeys[newTail];\n\n    // Overview of O(n) reconciliation algorithm (general approach based on\n    // ideas found in ivi, vue, snabbdom, etc.):\n    //\n    // * We start with the list of old parts and new results (and arrays of\n    //   their respective keys), head/tail pointers into each, and we build\n    //   up the new list of parts by updating (and when needed, moving) old\n    //   parts or creating new ones. The initial scenario might look like this\n    //   (for brevity of the diagrams, the numbers in the array reflect \"keys\"\n    //   associated with the old parts or new results, although they are\n    //   actually stored in parallel arrays indexed using the same head/tail\n    //   pointers):\n    //\n    //        oldHead v                 v oldTail\n    //   oldParts:   [0, 1, 2, 3, 4, 5, 6]\n    //   newParts:   [ ,  ,  ,  ,  ,  ,  ]\n    //   newResults: [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new item order\n    //        newHead ^                 ^ newTail\n    //\n    // * Iterate old & new lists from both sides, updating, swapping, or\n    //   removing parts at the head/tail locations until neither head nor tail\n    //   can move.\n    //\n    // * Example below: keys at head pointers match, so update old part 0 in-\n    //   place (no need to move it) and record part 0 in the `newParts` list.\n    //   The last thing we do is advance the `oldHead` and `newHead` pointers\n    //   (will be reflected in the next diagram).\n    //\n    //        oldHead v                 v oldTail\n    //   oldParts:   [0, 1, 2, 3, 4, 5, 6]\n    //   newParts:   [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0 and\n    //   newResults: [0, 2, 1, 4, 3, 7, 6]    advance both oldHead & newHead\n    //        newHead ^                 ^ newTail\n    //\n    // * Example below: head pointers don't match, but tail pointers do, so\n    //   update part 6 in place (no need to move it), and record part 6 in the\n    //   `newParts` list. Last, advance the `oldTail` and `oldHead` pointers.\n    //\n    //           oldHead v              v oldTail\n    //   oldParts:   [0, 1, 2, 3, 4, 5, 6]\n    //   newParts:   [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6 and\n    //   newResults: [0, 2, 1, 4, 3, 7, 6]    advance both oldTail & newTail\n    //           newHead ^              ^ newTail\n    //\n    // * Example below: neither head nor tail match; next check if one of the\n    //   old head/tail items was removed.  The key at `oldTail` was removed\n    //   (no longer in the `newKeyToIndexMap`), so remove that part from the\n    //   DOM and advance just the `oldTail` pointer.\n    //\n    //           oldHead v           v oldTail\n    //   oldParts:   [0, 1, 2, 3, 4, 5, 6]\n    //   newParts:   [0,  ,  ,  ,  ,  , 6] <- 5 not in new map; remove 5 and\n    //   newResults: [0, 2, 1, 4, 3, 7, 6]    advance oldTail\n    //           newHead ^           ^ newTail\n    //\n    // * Once head and tail cannot move, any mismatches are due to either new or\n    //   moved items; if a new key is in the previous \"old key to old index\"\n    //   map, find the old part and move it to the new location, otherwise\n    //   create and insert a new part. Note that when moving an old part we\n    //   null its position in the oldParts array if it lies between the head\n    //   and tail so we know to skip it when the pointers get there.\n    //\n    // * Example below: neither head nor tail match, and neither were removed;\n    //   so find the `newHead` key in the `oldKeyToIndexMap`, and move that old\n    //   part's DOM into the next head position (before `oldParts[oldHead]`).\n    //   Last, null the part in the `oldPart` array since it was somewhere in\n    //   the remaining oldParts still to be scanned (between the head and tail\n    //   pointers) so that we know to skip that old part on future iterations.\n    //\n    //           oldHead v        v oldTail\n    //   oldParts:   [0, 1, -, 3, 4, 5, 6]\n    //   newParts:   [0, 2,  ,  ,  ,  , 6] <- stuck; update & move 2 into place\n    //   newResults: [0, 2, 1, 4, 3, 7, 6]    and advance newHead\n    //           newHead ^           ^ newTail\n    //\n    // * Note that for moves/insertions like the one above, a part inserted at\n    //   the head pointer is inserted before the current `oldParts[oldHead]`,\n    //   and a part inserted at the tail pointer is inserted before\n    //   `newParts[newHead+1]`. The seeming asymmetry lies in the fact that new\n    //   parts are moved into place outside in, so to the right of the head\n    //   pointer are old parts, and to the right of the tail pointer are new\n    //   parts.\n    //\n    // * We always restart back from the top of the algorithm, allowing matching\n    //   and simple updates in place to continue...\n    //\n    // * Example below: the head pointers once again match, so simply update\n    //   part 1 and record it in the `newParts` array.  Last, advance both head\n    //   pointers.\n    //\n    //           oldHead v        v oldTail\n    //   oldParts:   [0, 1, -, 3, 4, 5, 6]\n    //   newParts:   [0, 2, 1,  ,  ,  , 6] <- heads matched; update 1 and\n    //   newResults: [0, 2, 1, 4, 3, 7, 6]    advance both oldHead & newHead\n    //              newHead ^        ^ newTail\n    //\n    // * As mentioned above, items that were moved as a result of being stuck\n    //   (the final else clause in the code below) are marked with null, so we\n    //   always advance old pointers over these so we're comparing the next\n    //   actual old value on either end.\n    //\n    // * Example below: `oldHead` is null (already placed in newParts), so\n    //   advance `oldHead`.\n    //\n    //              oldHead v     v oldTail\n    //   oldParts:   [0, 1, -, 3, 4, 5, 6] // old head already used; advance\n    //   newParts:   [0, 2, 1,  ,  ,  , 6] // oldHead\n    //   newResults: [0, 2, 1, 4, 3, 7, 6]\n    //                 newHead ^     ^ newTail\n    //\n    // * Note it's not critical to mark old parts as null when they are moved\n    //   from head to tail or tail to head, since they will be outside the\n    //   pointer range and never visited again.\n    //\n    // * Example below: Here the old tail key matches the new head key, so\n    //   the part at the `oldTail` position and move its dom to the new\n    //   head position (before `oldParts[oldHead]`). Last, advance `oldTail`\n    //   and `newHead` pointers.\n    //\n    //                 oldHead v  v oldTail\n    //   oldParts:   [0, 1, -, 3, 4, 5, 6]\n    //   newParts:   [0, 2, 1, 4,  ,  , 6] <- old tail matches new head: update\n    //   newResults: [0, 2, 1, 4, 3, 7, 6]   & move 4, advance oldTail & newHead\n    //                 newHead ^     ^ newTail\n    //\n    // * Example below: Old and new head keys match, so update the old head\n    //   part in place, and advance the `oldHead` and `newHead` pointers.\n    //\n    //                 oldHead v oldTail\n    //   oldParts:   [0, 1, -, 3, 4, 5, 6]\n    //   newParts:   [0, 2, 1, 4, 3,   ,6] <- heads match: update 3 and advance\n    //   newResults: [0, 2, 1, 4, 3, 7, 6]    oldHead & newHead\n    //                    newHead ^  ^ newTail\n    //\n    // * Once the new or old pointers move past each other then all we have\n    //   left is additions (if old list exhausted) or removals (if new list\n    //   exhausted). Those are handled in the final while loops at the end.\n    //\n    // * Example below: `oldHead` exceeded `oldTail`, so we're done with the\n    //   main loop.  Create the remaining part and insert it at the new head\n    //   position, and the update is complete.\n    //\n    //                   (oldHead > oldTail)\n    //   oldParts:   [0, 1, -, 3, 4, 5, 6]\n    //   newParts:   [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7\n    //   newResults: [0, 2, 1, 4, 3, 7, 6]\n    //                       newHead ^ newTail\n    //\n    // * Note that the order of the if/else clauses is not important to the\n    //   algorithm, as long as the null checks come first (to ensure we're\n    //   always working on valid old parts) and that the final else clause\n    //   comes last (since that's where the expensive moves occur). The\n    //   order of remaining clauses is is just a simple guess at which cases\n    //   will be most common.\n    //\n    // * TODO(kschaaf) Note, we could calculate the longest increasing\n    //   subsequence (LIS) of old items in new position, and only move those not\n    //   in the LIS set. However that costs O(nlogn) time and adds a bit more\n    //   code, and only helps make rare types of mutations require fewer moves.\n    //   The above handles removes, adds, reversal, swaps, and single moves of\n    //   contiguous items in linear time, in the minimum number of moves. As\n    //   the number of multiple moves where LIS might help approaches a random\n    //   shuffle, the LIS optimization becomes less helpful, so it seems not\n    //   worth the code at this point. Could reconsider if a compelling case\n    //   arises.\n\n    while (oldHead <= oldTail && newHead <= newTail) {\n      if (oldHeadPart === null) {\n        // `null` means old part at head has already been used below; skip\n        oldHeadPart = oldParts[++oldHead];\n      } else if (oldTailPart === null) {\n        // `null` means old part at tail has already been used below; skip\n        oldTailPart = oldParts[--oldTail];\n      } else if (oldHeadPart.key === newHeadResult.key) {\n        // Old head matches new head; update in place\n        newParts[newHead] = updatePart(oldHeadPart!, newResults[newHead]);\n        newHeadResult = newResults[++newHead];\n        oldHeadPart = oldParts[++oldHead];\n      } else if (oldTailPart.key === newTailResult.key) {\n        // Old tail matches new tail; update in place\n        newParts[newTail] = updatePart(oldTailPart!, newResults[newTail]);\n        newTailResult = newResults[--newTail];\n        oldTailPart = oldParts[--oldTail];\n      } else if (!newKeyToIndexMap.has(oldHeadPart.key)) {\n        // Old head is no longer in new list; remove\n        removePart(oldHeadPart!);\n        oldHeadPart = oldParts[++oldHead];\n      } else if (!newKeyToIndexMap.has(oldTailPart.key)) {\n        // Old tail is no longer in new list; remove\n        removePart(oldTailPart!);\n        oldTailPart = oldParts[--oldTail];\n      } else if (oldHeadPart.key === newTailResult.key) {\n        // Old head matches new tail; update and move to new tail\n        newParts[newTail] = updatePart(oldHeadPart!, newTailResult);\n        insertPartBefore(containerPart, oldHeadPart!, newParts[newTail + 1]);\n        newTailResult = newResults[--newTail];\n        oldHeadPart = oldParts[++oldHead];\n      } else if (oldTailPart.key === newHeadResult.key) {\n        // Old tail matches new head; update and move to new head\n        newParts[newHead] = updatePart(oldTailPart!, newHeadResult);\n        insertPartBefore(containerPart, oldTailPart!, oldHeadPart!);\n        newHeadResult = newResults[++newHead];\n        oldTailPart = oldParts[--oldTail];\n      } else {\n        // Any mismatches at this point are due to additions or moves; see if\n        // we have an old part we can reuse and move into place\n        const oldIndex = oldKeyToIndexMap.get(newHeadResult.key);\n        const oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;\n        if (oldPart == null) {\n          // No old part for this result; create a new one and insert it\n          let newPart = createAndInsertPart(containerPart, oldHeadPart!);\n          newPart.key = newHeadResult.key;\n          updatePart(newPart, newHeadResult);\n          newParts[newHead] = newPart;\n        } else {\n          // Reuse old part\n          newParts[newHead] = updatePart(oldPart, newHeadResult);\n          insertPartBefore(containerPart, oldPart, oldHeadPart!);\n          // This marks the old part as having been used, so that it will be\n          // skipped in the first two checks above\n          oldParts[oldIndex as number] = null;\n        }\n        newHeadResult = newResults[++newHead];\n      }\n    }\n    // Add parts for any remaining new results\n    while (newHead <= newTail) {\n      const newPart = createAndInsertPart(containerPart, oldHeadPart!);\n      const newResult = newResults[newHead];\n      newPart.key = newResult.key;\n      updatePart(newPart, newResult);\n      newParts[newHead++] = newPart;\n    }\n    // Remove any remaining unused old parts\n    while (oldHead <= oldTail) {\n      const oldPart = oldParts[oldHead++];\n      if (oldPart !== null) {\n        removePart(oldPart);\n      }\n    }\n    // Save order of new parts for next round\n    partListCache.set(containerPart, newParts);\n    // keyListCache.set(containerPart, newKeys);\n    keyToIndexMapCache.set(containerPart, newKeyToIndexMap);\n  });\n}\n"]}